import {posix as path} from "path"
import * as process from "node:process";
import {readFile, readdir, writeFile} from "fs/promises"

const GENERATED_DIRNAME = path.join(process.cwd(), "src", "generated")
const GENERATED_FILENAME = path.join(GENERATED_DIRNAME, "events.ts")
const EVENTS_DIR = path.join(process.cwd(), "src", "events");

async function getAllEventsPathsInDirRecursive(dir: string): Promise<string[]> {
    const dirContents = await readdir(dir)
    const results: string[] = [];
    for (const thing of dirContents) {
        if (thing.endsWith(".ts")) {
            results.push(path.join(dir, thing))
        }
        else {
            const innerResults = await getAllEventsPathsInDirRecursive(path.join(dir, thing))
            results.push(...innerResults)
        }
    }
    return results;
}

const identifierPattern = /.*\s([\S]+)\s?=/
function parseIdentifier(file: string, line: string) {
    const matches = line.match(identifierPattern)
    if (!matches) {
        throw new Error(`Unable to parse identifier for ${file}:${line}`)
    }
    return matches[1];
}

function extractEventNameFromFilePath(file: string) {
    const fileName = file.split(path.sep).reverse()[0];
    return fileName.substring(0, fileName.lastIndexOf(".ts"));
}

function removeExtension(file: string) {
    return file.substring(0, file.lastIndexOf("."));
}

async function generateEvent(file: string): Promise<{import: string, definition: string, eventName: string}> {
    try {
        const contents = await readFile(file, "utf8")
        const lines = contents.split("\n");
        let eventType = "";
        let eventMessage = "";

        let pointer = 0;
        while (pointer < lines.length) {
            const line = lines[pointer];
            if (line.includes("@event-type")) {
                pointer++;
                eventType = parseIdentifier(file, lines[pointer])
            } else if (line.includes("@event-message")) {
                pointer++;
                eventMessage = parseIdentifier(file, lines[pointer])
            }
            pointer++;
        }

        if (!eventType || !eventMessage) {
            throw new Error(`Incomplete event definition in ${file}`)
        }
        const eventName = extractEventNameFromFilePath(file);
        const importPath = removeExtension(path.relative(GENERATED_DIRNAME, file))
        return {
            import: `import {${eventType}, ${eventMessage}} from "${importPath}"`,
            definition: `export interface ${eventName} extends PMSEvent<typeof ${eventType}, ${eventMessage}> {}`,
            eventName
        }
    }
    catch (e) {
        throw new Error(`Error in file ${file}: ${e}`);
    }
}

async function writeEventsFile(events: {import: string, definition: string, eventName: string}[]) {
    let file =""
    file += "// This file is autogenerated. Changes made inside this file will not be preserved.\n\n"
    file += `import {PMSEvent} from "${removeExtension(path.relative(GENERATED_DIRNAME, path.join(process.cwd(), "src", "models", "PMSEvent.ts")))}"`;
    for (const event of events) {
        file += "\n" + event.import;
    }
    file += "\n";
    for (const event of events) {
        file += "\n" + event.definition + "\n";
    }
    file += "\n"
    file += "export type Event = \n"
    const eventNames = events.map(({eventName}) => eventName).join(" |\n  ");
    file += "  " + eventNames + ";"
    await writeFile(GENERATED_FILENAME, file);
}

async function generate() {
    const files = await getAllEventsPathsInDirRecursive(EVENTS_DIR);
    const events = await Promise.all(files.map(generateEvent));
    await writeEventsFile(events);
}

generate();